// src/pages/api/cart/index.js
// import { getContext } from '@/lib/getContext';
import prisma from "@/lib/prisma";

export default async function handler(req, res) {
  try {
    console.log("üì© Incoming request:", req.method, req.query, req.body);

    // --- extract userId and sessionId from query ---
    const { userId, sessionId } = req.query;
    console.log("‚û°Ô∏è Extracted from query -> userId:", userId, "sessionId:", sessionId);

    // --- auth check ---
    if (!userId && !sessionId) {
      console.log("‚ùå Missing userId & sessionId");
      return res.status(401).json({ error: 'Authentication required (userId or sessionId)' });
    }

    // --- build where clause ---
    const ownerWhere = {};
    if (userId) ownerWhere.userId = parseInt(userId, 10);
    if (sessionId) ownerWhere.sessionId = sessionId;
    console.log("üîé ownerWhere:", ownerWhere);

    // ---------------- GET CART ----------------
    if (req.method === 'GET') {
      console.log("üöÄ Handling GET /cart");

      const rows = await prisma.cart.findMany({
        where: ownerWhere,
        include: { product: true },
        orderBy: { cartId: 'asc' },
      });
      console.log("üì¶ Cart rows:", rows);

      const items = rows.map(r => ({
        cartId: r.cartId,
        productId: r.productId,
        quantity: r.quantity,
        product: r.product,
        itemTotal: r.product.productPrice * r.quantity,
      }));
      console.log("üõçÔ∏è Processed items:", items);

      const grandTotal = items.reduce((sum, it) => sum + it.itemTotal, 0);
      console.log("üí∞ Grand total:", grandTotal);

      return res.status(200).json({ items, grandTotal });
    }

    // ---------------- ADD SINGLE ITEM ----------------
    if (req.method === 'POST') {
      console.log("üöÄ Handling POST /cart");

      const { productId, quantity = 1 } = req.body;
      console.log("‚û°Ô∏è Body productId:", productId, "quantity:", quantity);

      if (!productId) {
        console.log("‚ùå No productId provided");
        return res.status(400).json({ error: 'productId required' });
      }

      const pId = parseInt(productId, 10);
      const qty = Math.max(1, parseInt(quantity, 10));
      console.log("üî¢ Parsed productId:", pId, "qty:", qty);

      const result = await prisma.$transaction(async tx => {
        console.log("üö¶ Inside transaction");

        const product = await tx.products.findUnique({ where: { productId: pId } });
        console.log("üõí Found product:", product);

        if (!product) throw { status: 404, message: 'Product not found' };

        const existing = await tx.cart.findFirst({
          where: { productId: pId, ...(userId ? { userId: parseInt(userId, 10) } : { sessionId }) },
        });
        console.log("üì¶ Existing cart item:", existing);

        if (existing) {
          console.log("‚ö†Ô∏è Already exists in cart");
          return { action: 'exists', item: existing };
        }

        if (qty > product.productStock) {
          console.log("‚ùå Not enough stock. Requested:", qty, "Available:", product.productStock);
          throw { status: 400, message: `Only ${product.productStock} units available` };
        }

        const created = await tx.cart.create({
          data: {
            productId: pId,
            quantity: qty,
            ...(userId ? { userId: parseInt(userId, 10) } : { sessionId }),
          },
        });
        console.log("‚úÖ Created cart item:", created);

        return { action: 'created', item: created };
      });

      console.log("üéØ Transaction result:", result);

      if (result.item?.cartId) {
        const itemWithProduct = await prisma.cart.findUnique({
          where: { cartId: result.item.cartId },
          include: { product: true },
        });
        console.log("üì¶ Returning item with product:", itemWithProduct);

        return res
          .status(result.action === 'created' ? 201 : 200)
          .json({ action: result.action, item: itemWithProduct });
      }

      return res.status(200).json(result);
    }

    // ---------------- INVALID METHOD ----------------
    console.log("‚ùå Method not allowed:", req.method);
    return res.status(405).json({ error: 'Method not allowed' });

  } catch (err) {
    console.error("üî• API Error:", err);
    if (err?.status) return res.status(err.status).json({ error: err.message });
    return res.status(500).json({ error: 'Internal server error' });
  }
}